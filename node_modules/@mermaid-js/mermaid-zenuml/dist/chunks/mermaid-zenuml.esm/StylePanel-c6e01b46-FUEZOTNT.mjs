import {
  $8,
  B,
  Cr,
  Cz,
  F3,
  GB,
  GC,
  I,
  La,
  Lr,
  NL,
  O,
  P2,
  P4,
  R2,
  T,
  T2,
  T3,
  VC,
  W0,
  X6,
  Yf,
  _,
  _c,
  a3,
  e4,
  eL,
  f1,
  h3,
  i5,
  m1,
  m3,
  q2,
  s1,
  sp,
  v2,
  wa,
  x2,
  x3
} from "./chunk-TCFR7TDP.mjs";
import {
  __name
} from "./chunk-OS44DIFC.mjs";

// ../../node_modules/.pnpm/@zenuml+core@3.31.1_typescript@5.7.3/node_modules/@zenuml/core/dist/StylePanel-c6e01b46.js
var ze = ["top", "right", "bottom", "left"];
var Fe = ["start", "end"];
var Le = /* @__PURE__ */ ze.reduce((e, t) => e.concat(t, t + "-" + Fe[0], t + "-" + Fe[1]), []);
var Z = Math.min;
var q = Math.max;
var ae = Math.round;
var le = Math.floor;
var X = /* @__PURE__ */ __name((e) => ({
  x: e,
  y: e
}), "X");
var Bt = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var Dt = {
  start: "end",
  end: "start"
};
function ye(e, t, n) {
  return q(e, Z(t, n));
}
__name(ye, "ye");
function K(e, t) {
  return typeof e == "function" ? e(t) : e;
}
__name(K, "K");
function z(e) {
  return e.split("-")[0];
}
__name(z, "z");
function M(e) {
  return e.split("-")[1];
}
__name(M, "M");
function Ue(e) {
  return e === "x" ? "y" : "x";
}
__name(Ue, "Ue");
function be(e) {
  return e === "y" ? "height" : "width";
}
__name(be, "be");
function de(e) {
  return ["top", "bottom"].includes(z(e)) ? "y" : "x";
}
__name(de, "de");
function Ce(e) {
  return Ue(de(e));
}
__name(Ce, "Ce");
function Xe(e, t, n) {
  n === void 0 && (n = false);
  const i = M(e), o = Ce(e), r = be(o);
  let s = o === "x" ? i === (n ? "end" : "start") ? "right" : "left" : i === "start" ? "bottom" : "top";
  return t.reference[r] > t.floating[r] && (s = ue(s)), [s, ue(s)];
}
__name(Xe, "Xe");
function Nt(e) {
  const t = ue(e);
  return [ce(e), t, ce(t)];
}
__name(Nt, "Nt");
function ce(e) {
  return e.replace(/start|end/g, (t) => Dt[t]);
}
__name(ce, "ce");
function $t(e, t, n) {
  const i = ["left", "right"], o = ["right", "left"], r = ["top", "bottom"], s = ["bottom", "top"];
  switch (e) {
    case "top":
    case "bottom":
      return n ? t ? o : i : t ? i : o;
    case "left":
    case "right":
      return t ? r : s;
    default:
      return [];
  }
}
__name($t, "$t");
function kt(e, t, n, i) {
  const o = M(e);
  let r = $t(z(e), n === "start", i);
  return o && (r = r.map((s) => s + "-" + o), t && (r = r.concat(r.map(ce)))), r;
}
__name(kt, "kt");
function ue(e) {
  return e.replace(/left|right|bottom|top/g, (t) => Bt[t]);
}
__name(ue, "ue");
function jt(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
__name(jt, "jt");
function Ye(e) {
  return typeof e != "number" ? jt(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
__name(Ye, "Ye");
function fe(e) {
  const {
    x: t,
    y: n,
    width: i,
    height: o
  } = e;
  return {
    width: i,
    height: o,
    top: n,
    left: t,
    right: t + i,
    bottom: n + o,
    x: t,
    y: n
  };
}
__name(fe, "fe");
function Be(e, t, n) {
  let {
    reference: i,
    floating: o
  } = e;
  const r = de(t), s = Ce(t), l = be(s), u = z(t), c = r === "y", f = i.x + i.width / 2 - o.width / 2, m = i.y + i.height / 2 - o.height / 2, w = i[l] / 2 - o[l] / 2;
  let d;
  switch (u) {
    case "top":
      d = {
        x: f,
        y: i.y - o.height
      };
      break;
    case "bottom":
      d = {
        x: f,
        y: i.y + i.height
      };
      break;
    case "right":
      d = {
        x: i.x + i.width,
        y: m
      };
      break;
    case "left":
      d = {
        x: i.x - o.width,
        y: m
      };
      break;
    default:
      d = {
        x: i.x,
        y: i.y
      };
  }
  switch (M(t)) {
    case "start":
      d[s] -= w * (n && c ? -1 : 1);
      break;
    case "end":
      d[s] += w * (n && c ? -1 : 1);
      break;
  }
  return d;
}
__name(Be, "Be");
var _t = /* @__PURE__ */ __name(async (e, t, n) => {
  const {
    placement: i = "bottom",
    strategy: o = "absolute",
    middleware: r = [],
    platform: s
  } = n, l = r.filter(Boolean), u = await (s.isRTL == null ? void 0 : s.isRTL(t));
  let c = await s.getElementRects({
    reference: e,
    floating: t,
    strategy: o
  }), {
    x: f,
    y: m
  } = Be(c, i, u), w = i, d = {}, a = 0;
  for (let v = 0; v < l.length; v++) {
    const {
      name: g,
      fn: h
    } = l[v], {
      x: y,
      y: b,
      data: C,
      reset: O2
    } = await h({
      x: f,
      y: m,
      initialPlacement: i,
      placement: w,
      strategy: o,
      middlewareData: d,
      rects: c,
      platform: s,
      elements: {
        reference: e,
        floating: t
      }
    });
    f = y ?? f, m = b ?? m, d = {
      ...d,
      [g]: {
        ...d[g],
        ...C
      }
    }, O2 && a <= 50 && (a++, typeof O2 == "object" && (O2.placement && (w = O2.placement), O2.rects && (c = O2.rects === true ? await s.getElementRects({
      reference: e,
      floating: t,
      strategy: o
    }) : O2.rects), {
      x: f,
      y: m
    } = Be(c, w, u)), v = -1);
  }
  return {
    x: f,
    y: m,
    placement: w,
    strategy: o,
    middlewareData: d
  };
}, "_t");
async function oe(e, t) {
  var n;
  t === void 0 && (t = {});
  const {
    x: i,
    y: o,
    platform: r,
    rects: s,
    elements: l,
    strategy: u
  } = e, {
    boundary: c = "clippingAncestors",
    rootBoundary: f = "viewport",
    elementContext: m = "floating",
    altBoundary: w = false,
    padding: d = 0
  } = K(t, e), a = Ye(d), g = l[w ? m === "floating" ? "reference" : "floating" : m], h = fe(await r.getClippingRect({
    element: (n = await (r.isElement == null ? void 0 : r.isElement(g))) == null || n ? g : g.contextElement || await (r.getDocumentElement == null ? void 0 : r.getDocumentElement(l.floating)),
    boundary: c,
    rootBoundary: f,
    strategy: u
  })), y = m === "floating" ? {
    x: i,
    y: o,
    width: s.floating.width,
    height: s.floating.height
  } : s.reference, b = await (r.getOffsetParent == null ? void 0 : r.getOffsetParent(l.floating)), C = await (r.isElement == null ? void 0 : r.isElement(b)) ? await (r.getScale == null ? void 0 : r.getScale(b)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, O2 = fe(r.convertOffsetParentRelativeRectToViewportRelativeRect ? await r.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: l,
    rect: y,
    offsetParent: b,
    strategy: u
  }) : y);
  return {
    top: (h.top - O2.top + a.top) / C.y,
    bottom: (O2.bottom - h.bottom + a.bottom) / C.y,
    left: (h.left - O2.left + a.left) / C.x,
    right: (O2.right - h.right + a.right) / C.x
  };
}
__name(oe, "oe");
var Ht = /* @__PURE__ */ __name((e) => ({
  name: "arrow",
  options: e,
  async fn(t) {
    const {
      x: n,
      y: i,
      placement: o,
      rects: r,
      platform: s,
      elements: l,
      middlewareData: u
    } = t, {
      element: c,
      padding: f = 0
    } = K(e, t) || {};
    if (c == null)
      return {};
    const m = Ye(f), w = {
      x: n,
      y: i
    }, d = Ce(o), a = be(d), v = await s.getDimensions(c), g = d === "y", h = g ? "top" : "left", y = g ? "bottom" : "right", b = g ? "clientHeight" : "clientWidth", C = r.reference[a] + r.reference[d] - w[d] - r.floating[a], O2 = w[d] - r.reference[d], A = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(c));
    let p = A ? A[b] : 0;
    (!p || !await (s.isElement == null ? void 0 : s.isElement(A))) && (p = l.floating[b] || r.floating[a]);
    const T4 = C / 2 - O2 / 2, F = p / 2 - v[a] / 2 - 1, E = Z(m[h], F), B2 = Z(m[y], F), S = E, D = p - v[a] - B2, L = p / 2 - v[a] / 2 + T4, $ = ye(S, L, D), _2 = !u.arrow && M(o) != null && L !== $ && r.reference[a] / 2 - (L < S ? E : B2) - v[a] / 2 < 0, V = _2 ? L < S ? L - S : L - D : 0;
    return {
      [d]: w[d] + V,
      data: {
        [d]: $,
        centerOffset: L - $ - V,
        ..._2 && {
          alignmentOffset: V
        }
      },
      reset: _2
    };
  }
}), "Ht");
function Mt(e, t, n) {
  return (e ? [...n.filter((o) => M(o) === e), ...n.filter((o) => M(o) !== e)] : n.filter((o) => z(o) === o)).filter((o) => e ? M(o) === e || (t ? ce(o) !== o : false) : true);
}
__name(Mt, "Mt");
var Wt = /* @__PURE__ */ __name(function(e) {
  return e === void 0 && (e = {}), {
    name: "autoPlacement",
    options: e,
    async fn(t) {
      var n, i, o;
      const {
        rects: r,
        middlewareData: s,
        placement: l,
        platform: u,
        elements: c
      } = t, {
        crossAxis: f = false,
        alignment: m,
        allowedPlacements: w = Le,
        autoAlignment: d = true,
        ...a
      } = K(e, t), v = m !== void 0 || w === Le ? Mt(m || null, d, w) : w, g = await oe(t, a), h = ((n = s.autoPlacement) == null ? void 0 : n.index) || 0, y = v[h];
      if (y == null)
        return {};
      const b = Xe(y, r, await (u.isRTL == null ? void 0 : u.isRTL(c.floating)));
      if (l !== y)
        return {
          reset: {
            placement: v[0]
          }
        };
      const C = [g[z(y)], g[b[0]], g[b[1]]], O2 = [...((i = s.autoPlacement) == null ? void 0 : i.overflows) || [], {
        placement: y,
        overflows: C
      }], A = v[h + 1];
      if (A)
        return {
          data: {
            index: h + 1,
            overflows: O2
          },
          reset: {
            placement: A
          }
        };
      const p = O2.map((E) => {
        const B2 = M(E.placement);
        return [E.placement, B2 && f ? (
          // Check along the mainAxis and main crossAxis side.
          E.overflows.slice(0, 2).reduce((S, D) => S + D, 0)
        ) : (
          // Check only the mainAxis.
          E.overflows[0]
        ), E.overflows];
      }).sort((E, B2) => E[1] - B2[1]), F = ((o = p.filter((E) => E[2].slice(
        0,
        // Aligned placements should not check their opposite crossAxis
        // side.
        M(E[0]) ? 2 : 3
      ).every((B2) => B2 <= 0))[0]) == null ? void 0 : o[0]) || p[0][0];
      return F !== l ? {
        data: {
          index: h + 1,
          overflows: O2
        },
        reset: {
          placement: F
        }
      } : {};
    }
  };
}, "Wt");
var It = /* @__PURE__ */ __name(function(e) {
  return e === void 0 && (e = {}), {
    name: "flip",
    options: e,
    async fn(t) {
      var n, i;
      const {
        placement: o,
        middlewareData: r,
        rects: s,
        initialPlacement: l,
        platform: u,
        elements: c
      } = t, {
        mainAxis: f = true,
        crossAxis: m = true,
        fallbackPlacements: w,
        fallbackStrategy: d = "bestFit",
        fallbackAxisSideDirection: a = "none",
        flipAlignment: v = true,
        ...g
      } = K(e, t);
      if ((n = r.arrow) != null && n.alignmentOffset)
        return {};
      const h = z(o), y = z(l) === l, b = await (u.isRTL == null ? void 0 : u.isRTL(c.floating)), C = w || (y || !v ? [ue(l)] : Nt(l));
      !w && a !== "none" && C.push(...kt(l, v, a, b));
      const O2 = [l, ...C], A = await oe(t, g), p = [];
      let T4 = ((i = r.flip) == null ? void 0 : i.overflows) || [];
      if (f && p.push(A[h]), m) {
        const S = Xe(o, s, b);
        p.push(A[S[0]], A[S[1]]);
      }
      if (T4 = [...T4, {
        placement: o,
        overflows: p
      }], !p.every((S) => S <= 0)) {
        var F, E;
        const S = (((F = r.flip) == null ? void 0 : F.index) || 0) + 1, D = O2[S];
        if (D)
          return {
            data: {
              index: S,
              overflows: T4
            },
            reset: {
              placement: D
            }
          };
        let L = (E = T4.filter(($) => $.overflows[0] <= 0).sort(($, _2) => $.overflows[1] - _2.overflows[1])[0]) == null ? void 0 : E.placement;
        if (!L)
          switch (d) {
            case "bestFit": {
              var B2;
              const $ = (B2 = T4.map((_2) => [_2.placement, _2.overflows.filter((V) => V > 0).reduce((V, st) => V + st, 0)]).sort((_2, V) => _2[1] - V[1])[0]) == null ? void 0 : B2[0];
              $ && (L = $);
              break;
            }
            case "initialPlacement":
              L = l;
              break;
          }
        if (o !== L)
          return {
            reset: {
              placement: L
            }
          };
      }
      return {};
    }
  };
}, "It");
function De(e, t) {
  return {
    top: e.top - t.height,
    right: e.right - t.width,
    bottom: e.bottom - t.height,
    left: e.left - t.width
  };
}
__name(De, "De");
function Ne(e) {
  return ze.some((t) => e[t] >= 0);
}
__name(Ne, "Ne");
var Vt = /* @__PURE__ */ __name(function(e) {
  return e === void 0 && (e = {}), {
    name: "hide",
    options: e,
    async fn(t) {
      const {
        rects: n
      } = t, {
        strategy: i = "referenceHidden",
        ...o
      } = K(e, t);
      switch (i) {
        case "referenceHidden": {
          const r = await oe(t, {
            ...o,
            elementContext: "reference"
          }), s = De(r, n.reference);
          return {
            data: {
              referenceHiddenOffsets: s,
              referenceHidden: Ne(s)
            }
          };
        }
        case "escaped": {
          const r = await oe(t, {
            ...o,
            altBoundary: true
          }), s = De(r, n.floating);
          return {
            data: {
              escapedOffsets: s,
              escaped: Ne(s)
            }
          };
        }
        default:
          return {};
      }
    }
  };
}, "Vt");
async function zt(e, t) {
  const {
    placement: n,
    platform: i,
    elements: o
  } = e, r = await (i.isRTL == null ? void 0 : i.isRTL(o.floating)), s = z(n), l = M(n), u = de(n) === "y", c = ["left", "top"].includes(s) ? -1 : 1, f = r && u ? -1 : 1, m = K(t, e);
  let {
    mainAxis: w,
    crossAxis: d,
    alignmentAxis: a
  } = typeof m == "number" ? {
    mainAxis: m,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...m
  };
  return l && typeof a == "number" && (d = l === "end" ? a * -1 : a), u ? {
    x: d * f,
    y: w * c
  } : {
    x: w * c,
    y: d * f
  };
}
__name(zt, "zt");
var Ut = /* @__PURE__ */ __name(function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      var n, i;
      const {
        x: o,
        y: r,
        placement: s,
        middlewareData: l
      } = t, u = await zt(t, e);
      return s === ((n = l.offset) == null ? void 0 : n.placement) && (i = l.arrow) != null && i.alignmentOffset ? {} : {
        x: o + u.x,
        y: r + u.y,
        data: {
          ...u,
          placement: s
        }
      };
    }
  };
}, "Ut");
var Xt = /* @__PURE__ */ __name(function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: i,
        placement: o
      } = t, {
        mainAxis: r = true,
        crossAxis: s = false,
        limiter: l = {
          fn: /* @__PURE__ */ __name((g) => {
            let {
              x: h,
              y
            } = g;
            return {
              x: h,
              y
            };
          }, "fn")
        },
        ...u
      } = K(e, t), c = {
        x: n,
        y: i
      }, f = await oe(t, u), m = de(z(o)), w = Ue(m);
      let d = c[w], a = c[m];
      if (r) {
        const g = w === "y" ? "top" : "left", h = w === "y" ? "bottom" : "right", y = d + f[g], b = d - f[h];
        d = ye(y, d, b);
      }
      if (s) {
        const g = m === "y" ? "top" : "left", h = m === "y" ? "bottom" : "right", y = a + f[g], b = a - f[h];
        a = ye(y, a, b);
      }
      const v = l.fn({
        ...t,
        [w]: d,
        [m]: a
      });
      return {
        ...v,
        data: {
          x: v.x - n,
          y: v.y - i
        }
      };
    }
  };
}, "Xt");
function te(e) {
  return qe(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
__name(te, "te");
function N(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
__name(N, "N");
function U(e) {
  var t;
  return (t = (qe(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
__name(U, "U");
function qe(e) {
  return e instanceof Node || e instanceof N(e).Node;
}
__name(qe, "qe");
function W(e) {
  return e instanceof Element || e instanceof N(e).Element;
}
__name(W, "W");
function I2(e) {
  return e instanceof HTMLElement || e instanceof N(e).HTMLElement;
}
__name(I2, "I");
function $e(e) {
  return typeof ShadowRoot > "u" ? false : e instanceof ShadowRoot || e instanceof N(e).ShadowRoot;
}
__name($e, "$e");
function se(e) {
  const {
    overflow: t,
    overflowX: n,
    overflowY: i,
    display: o
  } = j(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + i + n) && !["inline", "contents"].includes(o);
}
__name(se, "se");
function Yt(e) {
  return ["table", "td", "th"].includes(te(e));
}
__name(Yt, "Yt");
function Oe(e) {
  const t = Ae(), n = j(e);
  return n.transform !== "none" || n.perspective !== "none" || (n.containerType ? n.containerType !== "normal" : false) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : false) || !t && (n.filter ? n.filter !== "none" : false) || ["transform", "perspective", "filter"].some((i) => (n.willChange || "").includes(i)) || ["paint", "layout", "strict", "content"].some((i) => (n.contain || "").includes(i));
}
__name(Oe, "Oe");
function qt(e) {
  let t = Y(e);
  for (; I2(t) && !ee(t); ) {
    if (Oe(t))
      return t;
    t = Y(t);
  }
  return null;
}
__name(qt, "qt");
function Ae() {
  return typeof CSS > "u" || !CSS.supports ? false : CSS.supports("-webkit-backdrop-filter", "none");
}
__name(Ae, "Ae");
function ee(e) {
  return ["html", "body", "#document"].includes(te(e));
}
__name(ee, "ee");
function j(e) {
  return N(e).getComputedStyle(e);
}
__name(j, "j");
function me(e) {
  return W(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.pageXOffset,
    scrollTop: e.pageYOffset
  };
}
__name(me, "me");
function Y(e) {
  if (te(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    $e(e) && e.host || // Fallback.
    U(e)
  );
  return $e(t) ? t.host : t;
}
__name(Y, "Y");
function Ge(e) {
  const t = Y(e);
  return ee(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : I2(t) && se(t) ? t : Ge(t);
}
__name(Ge, "Ge");
function ie(e, t, n) {
  var i;
  t === void 0 && (t = []), n === void 0 && (n = true);
  const o = Ge(e), r = o === ((i = e.ownerDocument) == null ? void 0 : i.body), s = N(o);
  return r ? t.concat(s, s.visualViewport || [], se(o) ? o : [], s.frameElement && n ? ie(s.frameElement) : []) : t.concat(o, ie(o, [], n));
}
__name(ie, "ie");
function Ke(e) {
  const t = j(e);
  let n = parseFloat(t.width) || 0, i = parseFloat(t.height) || 0;
  const o = I2(e), r = o ? e.offsetWidth : n, s = o ? e.offsetHeight : i, l = ae(n) !== r || ae(i) !== s;
  return l && (n = r, i = s), {
    width: n,
    height: i,
    $: l
  };
}
__name(Ke, "Ke");
function Te(e) {
  return W(e) ? e : e.contextElement;
}
__name(Te, "Te");
function J(e) {
  const t = Te(e);
  if (!I2(t))
    return X(1);
  const n = t.getBoundingClientRect(), {
    width: i,
    height: o,
    $: r
  } = Ke(t);
  let s = (r ? ae(n.width) : n.width) / i, l = (r ? ae(n.height) : n.height) / o;
  return (!s || !Number.isFinite(s)) && (s = 1), (!l || !Number.isFinite(l)) && (l = 1), {
    x: s,
    y: l
  };
}
__name(J, "J");
var Gt = /* @__PURE__ */ X(0);
function Qe(e) {
  const t = N(e);
  return !Ae() || !t.visualViewport ? Gt : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
__name(Qe, "Qe");
function Kt(e, t, n) {
  return t === void 0 && (t = false), !n || t && n !== N(e) ? false : t;
}
__name(Kt, "Kt");
function G(e, t, n, i) {
  t === void 0 && (t = false), n === void 0 && (n = false);
  const o = e.getBoundingClientRect(), r = Te(e);
  let s = X(1);
  t && (i ? W(i) && (s = J(i)) : s = J(e));
  const l = Kt(r, n, i) ? Qe(r) : X(0);
  let u = (o.left + l.x) / s.x, c = (o.top + l.y) / s.y, f = o.width / s.x, m = o.height / s.y;
  if (r) {
    const w = N(r), d = i && W(i) ? N(i) : i;
    let a = w, v = a.frameElement;
    for (; v && i && d !== a; ) {
      const g = J(v), h = v.getBoundingClientRect(), y = j(v), b = h.left + (v.clientLeft + parseFloat(y.paddingLeft)) * g.x, C = h.top + (v.clientTop + parseFloat(y.paddingTop)) * g.y;
      u *= g.x, c *= g.y, f *= g.x, m *= g.y, u += b, c += C, a = N(v), v = a.frameElement;
    }
  }
  return fe({
    width: f,
    height: m,
    x: u,
    y: c
  });
}
__name(G, "G");
var Qt = [":popover-open", ":modal"];
function Se(e) {
  return Qt.some((t) => {
    try {
      return e.matches(t);
    } catch {
      return false;
    }
  });
}
__name(Se, "Se");
function Jt(e) {
  let {
    elements: t,
    rect: n,
    offsetParent: i,
    strategy: o
  } = e;
  const r = o === "fixed", s = U(i), l = t ? Se(t.floating) : false;
  if (i === s || l && r)
    return n;
  let u = {
    scrollLeft: 0,
    scrollTop: 0
  }, c = X(1);
  const f = X(0), m = I2(i);
  if ((m || !m && !r) && ((te(i) !== "body" || se(s)) && (u = me(i)), I2(i))) {
    const w = G(i);
    c = J(i), f.x = w.x + i.clientLeft, f.y = w.y + i.clientTop;
  }
  return {
    width: n.width * c.x,
    height: n.height * c.y,
    x: n.x * c.x - u.scrollLeft * c.x + f.x,
    y: n.y * c.y - u.scrollTop * c.y + f.y
  };
}
__name(Jt, "Jt");
function Zt(e) {
  return Array.from(e.getClientRects());
}
__name(Zt, "Zt");
function Je(e) {
  return G(U(e)).left + me(e).scrollLeft;
}
__name(Je, "Je");
function en(e) {
  const t = U(e), n = me(e), i = e.ownerDocument.body, o = q(t.scrollWidth, t.clientWidth, i.scrollWidth, i.clientWidth), r = q(t.scrollHeight, t.clientHeight, i.scrollHeight, i.clientHeight);
  let s = -n.scrollLeft + Je(e);
  const l = -n.scrollTop;
  return j(i).direction === "rtl" && (s += q(t.clientWidth, i.clientWidth) - o), {
    width: o,
    height: r,
    x: s,
    y: l
  };
}
__name(en, "en");
function tn(e, t) {
  const n = N(e), i = U(e), o = n.visualViewport;
  let r = i.clientWidth, s = i.clientHeight, l = 0, u = 0;
  if (o) {
    r = o.width, s = o.height;
    const c = Ae();
    (!c || c && t === "fixed") && (l = o.offsetLeft, u = o.offsetTop);
  }
  return {
    width: r,
    height: s,
    x: l,
    y: u
  };
}
__name(tn, "tn");
function nn(e, t) {
  const n = G(e, true, t === "fixed"), i = n.top + e.clientTop, o = n.left + e.clientLeft, r = I2(e) ? J(e) : X(1), s = e.clientWidth * r.x, l = e.clientHeight * r.y, u = o * r.x, c = i * r.y;
  return {
    width: s,
    height: l,
    x: u,
    y: c
  };
}
__name(nn, "nn");
function ke(e, t, n) {
  let i;
  if (t === "viewport")
    i = tn(e, n);
  else if (t === "document")
    i = en(U(e));
  else if (W(t))
    i = nn(t, n);
  else {
    const o = Qe(e);
    i = {
      ...t,
      x: t.x - o.x,
      y: t.y - o.y
    };
  }
  return fe(i);
}
__name(ke, "ke");
function Ze(e, t) {
  const n = Y(e);
  return n === t || !W(n) || ee(n) ? false : j(n).position === "fixed" || Ze(n, t);
}
__name(Ze, "Ze");
function on(e, t) {
  const n = t.get(e);
  if (n)
    return n;
  let i = ie(e, [], false).filter((l) => W(l) && te(l) !== "body"), o = null;
  const r = j(e).position === "fixed";
  let s = r ? Y(e) : e;
  for (; W(s) && !ee(s); ) {
    const l = j(s), u = Oe(s);
    !u && l.position === "fixed" && (o = null), (r ? !u && !o : !u && l.position === "static" && !!o && ["absolute", "fixed"].includes(o.position) || se(s) && !u && Ze(e, s)) ? i = i.filter((f) => f !== s) : o = l, s = Y(s);
  }
  return t.set(e, i), i;
}
__name(on, "on");
function rn(e) {
  let {
    element: t,
    boundary: n,
    rootBoundary: i,
    strategy: o
  } = e;
  const s = [...n === "clippingAncestors" ? Se(t) ? [] : on(t, this._c) : [].concat(n), i], l = s[0], u = s.reduce((c, f) => {
    const m = ke(t, f, o);
    return c.top = q(m.top, c.top), c.right = Z(m.right, c.right), c.bottom = Z(m.bottom, c.bottom), c.left = q(m.left, c.left), c;
  }, ke(t, l, o));
  return {
    width: u.right - u.left,
    height: u.bottom - u.top,
    x: u.left,
    y: u.top
  };
}
__name(rn, "rn");
function sn(e) {
  const {
    width: t,
    height: n
  } = Ke(e);
  return {
    width: t,
    height: n
  };
}
__name(sn, "sn");
function ln(e, t, n) {
  const i = I2(t), o = U(t), r = n === "fixed", s = G(e, true, r, t);
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const u = X(0);
  if (i || !i && !r)
    if ((te(t) !== "body" || se(o)) && (l = me(t)), i) {
      const m = G(t, true, r, t);
      u.x = m.x + t.clientLeft, u.y = m.y + t.clientTop;
    } else
      o && (u.x = Je(o));
  const c = s.left + l.scrollLeft - u.x, f = s.top + l.scrollTop - u.y;
  return {
    x: c,
    y: f,
    width: s.width,
    height: s.height
  };
}
__name(ln, "ln");
function he(e) {
  return j(e).position === "static";
}
__name(he, "he");
function je(e, t) {
  return !I2(e) || j(e).position === "fixed" ? null : t ? t(e) : e.offsetParent;
}
__name(je, "je");
function et(e, t) {
  const n = N(e);
  if (Se(e))
    return n;
  if (!I2(e)) {
    let o = Y(e);
    for (; o && !ee(o); ) {
      if (W(o) && !he(o))
        return o;
      o = Y(o);
    }
    return n;
  }
  let i = je(e, t);
  for (; i && Yt(i) && he(i); )
    i = je(i, t);
  return i && ee(i) && he(i) && !Oe(i) ? n : i || qt(e) || n;
}
__name(et, "et");
var an = /* @__PURE__ */ __name(async function(e) {
  const t = this.getOffsetParent || et, n = this.getDimensions, i = await n(e.floating);
  return {
    reference: ln(e.reference, await t(e.floating), e.strategy),
    floating: {
      x: 0,
      y: 0,
      width: i.width,
      height: i.height
    }
  };
}, "an");
function cn(e) {
  return j(e).direction === "rtl";
}
__name(cn, "cn");
var un = {
  convertOffsetParentRelativeRectToViewportRelativeRect: Jt,
  getDocumentElement: U,
  getClippingRect: rn,
  getOffsetParent: et,
  getElementRects: an,
  getClientRects: Zt,
  getDimensions: sn,
  getScale: J,
  isElement: W,
  isRTL: cn
};
function fn(e, t) {
  let n = null, i;
  const o = U(e);
  function r() {
    var l;
    clearTimeout(i), (l = n) == null || l.disconnect(), n = null;
  }
  __name(r, "r");
  function s(l, u) {
    l === void 0 && (l = false), u === void 0 && (u = 1), r();
    const {
      left: c,
      top: f,
      width: m,
      height: w
    } = e.getBoundingClientRect();
    if (l || t(), !m || !w)
      return;
    const d = le(f), a = le(o.clientWidth - (c + m)), v = le(o.clientHeight - (f + w)), g = le(c), y = {
      rootMargin: -d + "px " + -a + "px " + -v + "px " + -g + "px",
      threshold: q(0, Z(1, u)) || 1
    };
    let b = true;
    function C(O2) {
      const A = O2[0].intersectionRatio;
      if (A !== u) {
        if (!b)
          return s();
        A ? s(false, A) : i = setTimeout(() => {
          s(false, 1e-7);
        }, 1e3);
      }
      b = false;
    }
    __name(C, "C");
    try {
      n = new IntersectionObserver(C, {
        ...y,
        // Handle <iframe>s
        root: o.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(C, y);
    }
    n.observe(e);
  }
  __name(s, "s");
  return s(true), r;
}
__name(fn, "fn");
function dn(e, t, n, i) {
  i === void 0 && (i = {});
  const {
    ancestorScroll: o = true,
    ancestorResize: r = true,
    elementResize: s = typeof ResizeObserver == "function",
    layoutShift: l = typeof IntersectionObserver == "function",
    animationFrame: u = false
  } = i, c = Te(e), f = o || r ? [...c ? ie(c) : [], ...ie(t)] : [];
  f.forEach((h) => {
    o && h.addEventListener("scroll", n, {
      passive: true
    }), r && h.addEventListener("resize", n);
  });
  const m = c && l ? fn(c, n) : null;
  let w = -1, d = null;
  s && (d = new ResizeObserver((h) => {
    let [y] = h;
    y && y.target === c && d && (d.unobserve(t), cancelAnimationFrame(w), w = requestAnimationFrame(() => {
      var b;
      (b = d) == null || b.observe(t);
    })), n();
  }), c && !u && d.observe(c), d.observe(t));
  let a, v = u ? G(e) : null;
  u && g();
  function g() {
    const h = G(e);
    v && (h.x !== v.x || h.y !== v.y || h.width !== v.width || h.height !== v.height) && n(), v = h, a = requestAnimationFrame(g);
  }
  __name(g, "g");
  return n(), () => {
    var h;
    f.forEach((y) => {
      o && y.removeEventListener("scroll", n), r && y.removeEventListener("resize", n);
    }), m == null || m(), (h = d) == null || h.disconnect(), d = null, u && cancelAnimationFrame(a);
  };
}
__name(dn, "dn");
var mn = Ut;
var pn = Wt;
var vn = Xt;
var gn = It;
var hn = Vt;
var wn = Ht;
var yn = /* @__PURE__ */ __name((e, t, n) => {
  const i = /* @__PURE__ */ new Map(), o = {
    platform: un,
    ...n
  }, r = {
    ...o.platform,
    _c: i
  };
  return _t(e, t, {
    ...o,
    platform: r
  });
}, "yn");
function xn(e) {
  return tt(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
__name(xn, "xn");
function bn(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
__name(bn, "bn");
function tt(e) {
  return e instanceof Node || e instanceof bn(e).Node;
}
__name(tt, "tt");
function Cn(e) {
  return e != null && typeof e == "object" && "$el" in e;
}
__name(Cn, "Cn");
function xe(e) {
  if (Cn(e)) {
    const t = e.$el;
    return tt(t) && xn(t) === "#comment" ? null : t;
  }
  return e;
}
__name(xe, "xe");
function On(e) {
  return {
    name: "arrow",
    options: e,
    fn(t) {
      const n = xe(O(e.element));
      return n == null ? {} : wn({
        element: n,
        padding: e.padding
      }).fn(t);
    }
  };
}
__name(On, "On");
function nt(e) {
  return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
__name(nt, "nt");
function _e(e, t) {
  const n = nt(e);
  return Math.round(t * n) / n;
}
__name(_e, "_e");
function An(e, t, n) {
  n === void 0 && (n = {});
  const i = n.whileElementsMounted, o = I(() => {
    var p;
    return (p = O(n.open)) != null ? p : true;
  }), r = I(() => O(n.middleware)), s = I(() => {
    var p;
    return (p = O(n.placement)) != null ? p : "bottom";
  }), l = I(() => {
    var p;
    return (p = O(n.strategy)) != null ? p : "absolute";
  }), u = I(() => {
    var p;
    return (p = O(n.transform)) != null ? p : true;
  }), c = I(() => xe(e.value)), f = I(() => xe(t.value)), m = R2(0), w = R2(0), d = R2(l.value), a = R2(s.value), v = Lr({}), g = R2(false), h = I(() => {
    const p = {
      position: d.value,
      left: "0",
      top: "0"
    };
    if (!f.value)
      return p;
    const T4 = _e(f.value, m.value), F = _e(f.value, w.value);
    return u.value ? {
      ...p,
      transform: "translate(" + T4 + "px, " + F + "px)",
      ...nt(f.value) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: d.value,
      left: T4 + "px",
      top: F + "px"
    };
  });
  let y;
  function b() {
    c.value == null || f.value == null || yn(c.value, f.value, {
      middleware: r.value,
      placement: s.value,
      strategy: l.value
    }).then((p) => {
      m.value = p.x, w.value = p.y, d.value = p.strategy, a.value = p.placement, v.value = p.middlewareData, g.value = true;
    });
  }
  __name(b, "b");
  function C() {
    typeof y == "function" && (y(), y = void 0);
  }
  __name(C, "C");
  function O2() {
    if (C(), i === void 0) {
      b();
      return;
    }
    if (c.value != null && f.value != null) {
      y = i(c.value, f.value, b);
      return;
    }
  }
  __name(O2, "O");
  function A() {
    o.value || (g.value = false);
  }
  __name(A, "A");
  return m3([r, s, l], b, {
    flush: "sync"
  }), m3([c, f], O2, {
    flush: "sync"
  }), m3(o, A, {
    flush: "sync"
  }), VC() && GC(C), {
    x: _c(m),
    y: _c(w),
    strategy: _c(d),
    placement: _c(a),
    middlewareData: _c(v),
    isPositioned: _c(g),
    floatingStyles: h,
    update: b
  };
}
__name(An, "An");
var Tn = Object.defineProperty;
var Sn = /* @__PURE__ */ __name((e, t, n) => t in e ? Tn(e, t, { enumerable: true, configurable: true, writable: true, value: n }) : e[t] = n, "Sn");
var En = /* @__PURE__ */ __name((e, t, n) => (Sn(e, typeof t != "symbol" ? t + "" : t, n), n), "En");
function re(e) {
  return e == null || e.value == null ? null : e.value instanceof Node ? e.value : "$el" in e.value && e.value.$el ? re(R2(e.value.$el)) : "getBoundingClientRect" in e.value ? e.value : null;
}
__name(re, "re");
function ot(e) {
  return e.reduce((t, n) => n.type === P2 ? t.concat(ot(n.children)) : t.concat(n), []);
}
__name(ot, "ot");
function Rn(e) {
  return e == null ? false : typeof e.type == "string" || typeof e.type == "object" || typeof e.type == "function";
}
__name(Rn, "Rn");
function He(e) {
  return e = O(e), e && (e == null ? void 0 : e.nodeType) !== Node.COMMENT_NODE;
}
__name(He, "He");
var Pn = class {
  static {
    __name(this, "Pn");
  }
  constructor() {
    En(this, "current", this.detect());
  }
  set(t) {
    this.current !== t && (this.current = t);
  }
  reset() {
    this.set(this.detect());
  }
  get isServer() {
    return this.current === "server";
  }
  get isClient() {
    return this.current === "client";
  }
  detect() {
    return typeof window > "u" || typeof document > "u" ? "server" : "client";
  }
};
var Ee = new Pn();
function Fn(e) {
  if (Ee.isServer)
    return null;
  if (e instanceof Node)
    return e.ownerDocument;
  if (Object.prototype.hasOwnProperty.call(e, "value")) {
    const t = re(e);
    if (t)
      return t.ownerDocument;
  }
  return document;
}
__name(Fn, "Fn");
function Ln(e, t) {
  !t.vueTransition && (t.transitionName || t.transitionType) && console.warn(`[headlessui-float]: <${e} /> pass "transition-name" or "transition-type" prop, must be set "vue-transition" prop.`);
}
__name(Ln, "Ln");
function Bn(e, t, n, i, o) {
  m3([
    () => o.offset,
    () => o.flip,
    () => o.shift,
    () => o.autoPlacement,
    () => o.arrow,
    () => o.hide,
    () => o.middleware
  ], () => {
    const r = [];
    (typeof o.offset == "number" || typeof o.offset == "object" || typeof o.offset == "function") && r.push(mn(o.offset)), (o.flip === true || typeof o.flip == "number" || typeof o.flip == "object") && r.push(gn({
      padding: typeof o.flip == "number" ? o.flip : void 0,
      ...typeof o.flip == "object" ? o.flip : {}
    })), (o.shift === true || typeof o.shift == "number" || typeof o.shift == "object") && r.push(vn({
      padding: typeof o.shift == "number" ? o.shift : void 0,
      ...typeof o.shift == "object" ? o.shift : {}
    })), (o.autoPlacement === true || typeof o.autoPlacement == "object") && r.push(pn(
      typeof o.autoPlacement == "object" ? o.autoPlacement : void 0
    )), r.push(...typeof o.middleware == "function" ? o.middleware({
      referenceEl: t,
      floatingEl: n
    }) : o.middleware || []), (o.arrow === true || typeof o.arrow == "number") && r.push(On({
      element: i,
      padding: o.arrow === true ? 0 : o.arrow
    })), (o.hide === true || typeof o.hide == "object" || Array.isArray(o.hide)) && (Array.isArray(o.hide) ? o.hide : [o.hide]).forEach((s) => {
      r.push(hn(
        typeof s == "object" ? s : void 0
      ));
    }), e.value = r;
  }, { immediate: true });
}
__name(Bn, "Bn");
function Dn(e, t, n) {
  let i = /* @__PURE__ */ __name(() => {
  }, "i");
  s1(() => {
    if (e && Ee.isClient && typeof ResizeObserver < "u" && t.value && t.value instanceof Element) {
      const o = new ResizeObserver(([r]) => {
        n.value = r.borderBoxSize.reduce((s, { inlineSize: l }) => s + l, 0);
      });
      o.observe(t.value), i = /* @__PURE__ */ __name(() => {
        o.disconnect(), n.value = null;
      }, "i");
    }
  }), W0(() => {
    i();
  });
}
__name(Dn, "Dn");
var Nn = /* @__PURE__ */ __name((e) => {
  switch (e) {
    case "top":
      return "origin-bottom";
    case "bottom":
      return "origin-top";
    case "left":
      return "origin-right";
    case "right":
      return "origin-left";
    case "top-start":
    case "right-end":
      return "origin-bottom-left";
    case "top-end":
    case "left-end":
      return "origin-bottom-right";
    case "right-start":
    case "bottom-start":
      return "origin-top-left";
    case "left-start":
    case "bottom-end":
      return "origin-top-right";
    default:
      return "origin-center";
  }
}, "Nn");
function $n(e, t) {
  const n = I(() => {
    if (typeof e.originClass == "function")
      return e.originClass(t.value);
    if (typeof e.originClass == "string")
      return e.originClass;
    if (e.tailwindcssOriginClass)
      return Nn(t.value);
  }), i = I(
    () => e.enter || n.value ? `${e.enter || ""} ${n.value || ""}` : void 0
  ), o = I(
    () => e.leave || n.value ? `${e.leave || ""} ${n.value || ""}` : void 0
  );
  return { originClassRef: n, enterActiveClassRef: i, leaveActiveClassRef: o };
}
__name($n, "$n");
function it(e, t, ...n) {
  if (e in t) {
    const o = t[e];
    return typeof o == "function" ? o(...n) : o;
  }
  const i = new Error(
    `Tried to handle "${e}" but there is no handler defined. Only defined handlers are: ${Object.keys(
      t
    ).map((o) => `"${o}"`).join(", ")}.`
  );
  throw Error.captureStackTrace && Error.captureStackTrace(i, it), i;
}
__name(it, "it");
var Me = [
  "[contentEditable=true]",
  "[tabindex]",
  "a[href]",
  "area[href]",
  "button:not([disabled])",
  "iframe",
  "input:not([disabled])",
  "select:not([disabled])",
  "textarea:not([disabled])"
].map(
  // TODO: Remove this once JSDOM fixes the issue where an element that is
  // "hidden" can be the document.activeElement, because this is not possible
  // in real browsers.
  (e) => `${e}:not([tabindex='-1'])`
).join(",");
var rt = /* @__PURE__ */ ((e) => (e[e.Strict = 0] = "Strict", e[e.Loose = 1] = "Loose", e))(rt || {});
function kn(e, t = 0) {
  var n;
  return e === ((n = Fn(e)) == null ? void 0 : n.body) ? false : it(t, {
    0() {
      return e.matches(Me);
    },
    1() {
      let i = e;
      for (; i !== null; ) {
        if (i.matches(Me))
          return true;
        i = i.parentElement;
      }
      return false;
    }
  });
}
__name(kn, "kn");
function we(e, t, n) {
  Ee.isServer || x3((i) => {
    document.addEventListener(e, t, n), i(() => document.removeEventListener(e, t, n));
  });
}
__name(we, "we");
function jn(e, t, n = I(() => true)) {
  function i(r, s) {
    if (!n.value || r.defaultPrevented)
      return;
    const l = s(r);
    if (l === null || !l.getRootNode().contains(l))
      return;
    const u = (/* @__PURE__ */ __name(function c(f) {
      return typeof f == "function" ? c(f()) : Array.isArray(f) || f instanceof Set ? f : [f];
    }, "c"))(e);
    for (const c of u) {
      if (c === null)
        continue;
      const f = c instanceof HTMLElement ? c : re(c);
      if (f != null && f.contains(l) || r.composed && r.composedPath().includes(f))
        return;
    }
    return (
      // This check alllows us to know whether or not we clicked on a "focusable" element like a
      // button or an input. This is a backwards compatibility check so that you can open a <Menu
      // /> and click on another <Menu /> which should close Menu A and open Menu B. We might
      // revisit that so that you will require 2 clicks instead.
      !kn(l, rt.Loose) && // This could be improved, but the `Combobox.Button` adds tabIndex={-1} to make it
      // unfocusable via the keyboard so that tabbing to the next item from the input doesn't
      // first go to the button.
      l.tabIndex !== -1 && r.preventDefault(), t(r, l)
    );
  }
  __name(i, "i");
  const o = R2(null);
  we("mousedown", (r) => {
    var s, l;
    n.value && (o.value = ((l = (s = r.composedPath) == null ? void 0 : s.call(r)) == null ? void 0 : l[0]) || r.target);
  }, true), we(
    "click",
    (r) => {
      o.value && (i(r, () => o.value), o.value = null);
    },
    // We will use the `capture` phase so that layers in between with `event.stopPropagation()`
    // don't "cancel" this outside click check. E.g.: A `Menu` inside a `DialogPanel` if the `Menu`
    // is open, and you click outside of it in the `DialogPanel` the `Menu` should close. However,
    // the `DialogPanel` has a `onClick(e) { e.stopPropagation() }` which would cancel this.
    true
  ), we("blur", (r) => i(
    r,
    () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null
  ), true);
}
__name(jn, "jn");
var _n = Symbol("ArrowContext");
var x = {
  as: {
    type: [String, Function],
    default: "template"
  },
  floatingAs: {
    type: [String, Function],
    default: "div"
  },
  show: {
    type: Boolean,
    default: null
  },
  placement: {
    type: String,
    default: "bottom-start"
  },
  strategy: {
    type: String,
    default: "absolute"
  },
  offset: [Number, Function, Object],
  shift: {
    type: [Boolean, Number, Object],
    default: false
  },
  flip: {
    type: [Boolean, Number, Object],
    default: false
  },
  arrow: {
    type: [Boolean, Number],
    default: false
  },
  autoPlacement: {
    type: [Boolean, Object],
    default: false
  },
  hide: {
    type: [Boolean, Object, Array],
    default: false
  },
  referenceHiddenClass: String,
  escapedClass: String,
  autoUpdate: {
    type: [Boolean, Object],
    default: true
  },
  zIndex: {
    type: [Number, String],
    default: 9999
  },
  vueTransition: {
    type: Boolean,
    default: false
  },
  transitionName: String,
  transitionType: String,
  enter: String,
  enterFrom: String,
  enterTo: String,
  leave: String,
  leaveFrom: String,
  leaveTo: String,
  originClass: [String, Function],
  tailwindcssOriginClass: {
    type: Boolean,
    default: false
  },
  portal: {
    type: Boolean,
    default: false
  },
  transform: {
    type: Boolean,
    default: false
  },
  adaptiveWidth: {
    type: [Boolean, Object],
    default: false
  },
  composable: {
    type: Boolean,
    default: false
  },
  dialog: {
    type: Boolean,
    default: false
  },
  middleware: {
    type: [Array, Function],
    default: /* @__PURE__ */ __name(() => [], "default")
  }
};
function Hn(e, t, n, i) {
  const { floatingRef: o, props: r, mounted: s, show: l, referenceHidden: u, escaped: c, placement: f, floatingStyles: m, referenceElWidth: w, updateFloating: d } = i, a = $8(
    { ...r, as: r.floatingAs },
    t
  ), { enterActiveClassRef: v, leaveActiveClassRef: g } = $n(a, f), h = {
    show: s.value ? a.show : false,
    enter: v.value,
    enterFrom: a.enterFrom,
    enterTo: a.enterTo,
    leave: g.value,
    leaveFrom: a.leaveFrom,
    leaveTo: a.leaveTo,
    onBeforeEnter() {
      l.value = true;
    },
    onAfterLeave() {
      l.value = false;
    }
  }, y = {
    name: a.transitionName,
    type: a.transitionType,
    appear: true,
    ...a.transitionName ? {} : {
      enterActiveClass: v.value,
      enterFromClass: a.enterFrom,
      enterToClass: a.enterTo,
      leaveActiveClass: g.value,
      leaveFromClass: a.leaveFrom,
      leaveToClass: a.leaveTo
    },
    onBeforeEnter() {
      l.value = true;
    },
    onAfterLeave() {
      l.value = false;
    }
  }, b = {
    class: [
      u.value ? a.referenceHiddenClass : void 0,
      c.value ? a.escapedClass : void 0
    ].filter((p) => !!p).join(" "),
    style: {
      ...m.value,
      zIndex: a.zIndex
    }
  };
  if (a.adaptiveWidth && typeof w.value == "number") {
    const p = {
      attribute: "width",
      ...typeof a.adaptiveWidth == "object" ? a.adaptiveWidth : {}
    };
    b.style[p.attribute] = `${w.value}px`;
  }
  function C(p) {
    return a.portal ? s.value ? f1(La, () => p) : x2() : p;
  }
  __name(C, "C");
  function O2(p) {
    const T4 = $8(
      b,
      n,
      a.dialog ? {} : { ref: o }
    );
    return a.as === "template" ? p : typeof a.as == "string" ? f1(a.as, T4, p) : f1(a.as, T4, () => p);
  }
  __name(O2, "O");
  function A() {
    function p() {
      var T4;
      const F = a.as === "template" ? $8(
        b,
        n,
        a.dialog ? {} : { ref: o }
      ) : null, E = T3(e, F);
      return ((T4 = e.props) == null ? void 0 : T4.unmount) === false ? (d(), E) : a.vueTransition && a.show === false ? x2() : E;
    }
    __name(p, "p");
    return s.value ? a.vueTransition ? f1(i5, {
      ...a.dialog ? { ref: o } : {},
      ...y
    }, p) : f1(a.transitionChild ? X6 : wa, {
      key: `placement-${f.value}`,
      ...a.dialog ? { ref: o } : {},
      as: "template",
      ...h
    }, p) : x2();
  }
  __name(A, "A");
  return C(
    O2(
      A()
    )
  );
}
__name(Hn, "Hn");
function Mn(e, t, n, i, o) {
  const r = R2(false), s = Cr(i, "placement"), l = Cr(i, "strategy"), u = Lr({}), c = R2(void 0), f = R2(void 0), m = R2(null), w = R2(void 0), d = R2(void 0), a = I(() => re(t)), v = I(() => re(n)), g = I(
    () => He(a) && He(v)
  ), { placement: h, middlewareData: y, isPositioned: b, floatingStyles: C, update: O2 } = An(a, v, {
    placement: s,
    strategy: l,
    middleware: u,
    // If enable dialog mode, then set `transform` to false.
    transform: i.dialog ? false : i.transform,
    // Fix transition not smooth bug when dialog mode enabled.
    whileElementsMounted: i.dialog ? () => () => {
    } : void 0
  }), A = R2(null);
  s1(() => {
    r.value = true;
  }), m3(e, (S, D) => {
    S && !D ? o("show") : !S && D && o("hide");
  }, { immediate: true });
  function p() {
    g.value && (O2(), o("update"));
  }
  __name(p, "p");
  m3([s, l, u], p, { flush: "sync" }), Bn(
    u,
    a,
    v,
    m,
    i
  ), m3([y, () => i.hide, b], () => {
    var S, D;
    (i.hide === true || typeof i.hide == "object" || Array.isArray(i.hide)) && (c.value = ((S = y.value.hide) == null ? void 0 : S.referenceHidden) || !b.value, f.value = (D = y.value.hide) == null ? void 0 : D.escaped);
  }), m3(y, () => {
    const S = y.value.arrow;
    w.value = S == null ? void 0 : S.x, d.value = S == null ? void 0 : S.y;
  }), Dn(!!i.adaptiveWidth, a, A), m3([e, g], async (S, D, L) => {
    if (await P4(), e.value && g.value && i.autoUpdate) {
      const $ = dn(
        a.value,
        v.value,
        p,
        typeof i.autoUpdate == "object" ? i.autoUpdate : void 0
      );
      L($);
    }
  }, { flush: "post", immediate: true });
  const T4 = R2(true);
  m3(a, () => {
    !(a.value instanceof Element) && g.value && T4.value && (T4.value = false, window.requestAnimationFrame(() => {
      T4.value = true, p();
    }));
  }, { flush: "sync" });
  const F = {
    referenceRef: t,
    placement: h
  }, E = {
    floatingRef: n,
    props: i,
    mounted: r,
    show: e,
    referenceHidden: c,
    escaped: f,
    placement: h,
    floatingStyles: C,
    referenceElWidth: A,
    updateFloating: p
  }, B2 = {
    ref: m,
    placement: h,
    x: w,
    y: d
  };
  return a3(_n, B2), { referenceApi: F, floatingApi: E, arrowApi: B2, placement: h, referenceEl: a, floatingEl: v, middlewareData: y, update: p };
}
__name(Mn, "Mn");
({
  ...x.as
});
var Wn = {
  as: x.as,
  show: x.show,
  placement: x.placement,
  strategy: x.strategy,
  offset: x.offset,
  shift: x.shift,
  flip: x.flip,
  arrow: x.arrow,
  autoPlacement: x.autoPlacement,
  autoUpdate: x.autoUpdate,
  zIndex: x.zIndex,
  vueTransition: x.vueTransition,
  transitionName: x.transitionName,
  transitionType: x.transitionType,
  enter: x.enter,
  enterFrom: x.enterFrom,
  enterTo: x.enterTo,
  leave: x.leave,
  leaveFrom: x.leaveFrom,
  leaveTo: x.leaveTo,
  originClass: x.originClass,
  tailwindcssOriginClass: x.tailwindcssOriginClass,
  portal: x.portal,
  transform: x.transform,
  middleware: x.middleware
};
var In = {
  name: "FloatVirtual",
  inheritAttrs: false,
  props: Wn,
  emits: ["initial", "show", "hide", "update"],
  setup(e, { emit: t, slots: n, attrs: i }) {
    Ln("FloatVirtual", e);
    const o = R2(e.show ?? false), r = R2({
      getBoundingClientRect() {
        return {
          x: 0,
          y: 0,
          top: 0,
          left: 0,
          bottom: 0,
          right: 0,
          width: 0,
          height: 0
        };
      }
    }), s = R2(null), {
      floatingApi: l,
      placement: u
    } = Mn(o, r, s, e, t);
    m3(() => e.show, () => {
      o.value = e.show ?? false;
    });
    function c() {
      o.value = false;
    }
    __name(c, "c");
    return t("initial", {
      show: o,
      placement: u,
      reference: r,
      floating: s
    }), () => {
      if (!n.default)
        return;
      const f = {
        placement: u.value,
        close: c
      }, [m] = ot(n.default(f)).filter(Rn);
      return Hn(
        m,
        {
          as: e.as,
          show: o.value
        },
        i,
        l
      );
    };
  }
};
x.as, x.placement, x.strategy, x.offset, x.shift, {
  ...x.flip
}, x.arrow, x.autoPlacement, x.autoUpdate, x.zIndex, x.vueTransition, x.transitionName, x.transitionType, x.enter, x.enterFrom, x.enterTo, x.leave, x.leaveFrom, x.leaveTo, x.originClass, x.tailwindcssOriginClass, x.transform, x.middleware;
var Vn = { class: "flex bg-white shadow-md z-10 rounded-md p-1" };
var zn = ["onClick"];
var Xn = /* @__PURE__ */ q2({
  __name: "StylePanel",
  setup(e) {
    GB({ WATCH_ARRAY: false });
    const t = R2({ value: null }), n = F3(), i = I(
      () => n.getters.onContentChange || (() => {
      })
    ), o = I(
      () => NL(n.getters.diagramElement) + sp
    ), r = I(() => n.getters.code), s = /* @__PURE__ */ __name((m) => {
      n.dispatch("updateCode", { code: m }), i.value(m);
    }, "s"), l = R2([]);
    let u;
    const c = /* @__PURE__ */ __name(({ show: m, reference: w, floating: d }) => {
      let a, v, g, h, y, b;
      n.commit("onMessageClick", (C, O2) => {
        var A;
        if (a = C.value.start.start, v = eL(r.value, a), g = Cz(r.value, a), h = ((A = r.value.slice(v).match(/^\s*/)) == null ? void 0 : A[0]) || "", y = g.trim().startsWith("//"), y) {
          const p = g.trimStart().slice(2).trimStart(), T4 = p.indexOf("["), F = p.indexOf("]");
          b = !!(T4 === 0 && F), b ? l.value = p.slice(T4 + 1, F).split(",").map((E) => E.trim()) : l.value = [];
        }
        w.value = {
          getBoundingClientRect: /* @__PURE__ */ __name(() => O2.getBoundingClientRect(), "getBoundingClientRect")
        }, t.value = C, m.value = true;
      }), jn(
        d,
        () => {
          m.value = false, l.value = [];
        },
        I(() => m.value)
      ), u = /* @__PURE__ */ __name((C) => {
        var O2;
        if (m.value = false, !!t.value.value)
          if (y) {
            let A = "";
            if (b) {
              let p;
              l.value.includes(C) ? p = l.value.filter((T4) => T4 !== C) : p = [...l.value, C], A = `${h}// [${p.filter(Boolean).join(", ")}] ${g.slice(g.indexOf("]") + 1).trimStart()}`;
            } else
              A = `${h}// [${C}] ${g.slice((((O2 = g.match(/\/\/*/)) == null ? void 0 : O2.index) || -2) + 2).trimStart()}`;
            A.endsWith(`
`) || (A += `
`), s(
              r.value.slice(0, Yf(r.value, a)) + A + r.value.slice(v)
            );
          } else
            s(
              r.value.slice(0, v) + `${h}// [${C}]
` + r.value.slice(v)
            );
      }, "u");
    }, "c"), f = [
      {
        name: "bold",
        content: "B",
        class: "font-bold"
      },
      {
        name: "italic",
        content: "I",
        class: "italic"
      },
      {
        name: "underline",
        content: "U",
        class: "underline"
      },
      {
        name: "strikethrough",
        content: "S",
        class: "line-through"
      }
    ];
    return (m, w) => (T(), T2(O(In), {
      "vue-transition": "",
      id: "style-panel",
      key: "tool",
      onInitial: c,
      placement: "top",
      offset: 5,
      flip: { padding: O(o) },
      shift: "",
      zIndex: "30"
    }, {
      default: h3(() => [
        _("div", Vn, [
          (T(), B(P2, null, e4(f, (d) => _("div", {
            onClick: /* @__PURE__ */ __name(() => O(u)(d.class), "onClick"),
            key: d.name
          }, [
            _("div", {
              class: v2(["w-6 mx-1 py-1 rounded-md text-black text-center cursor-pointer hover:bg-gray-200", [
                d.class,
                { "bg-gray-100": l.value.includes(d.class) }
              ]])
            }, m1(d.content), 3)
          ], 8, zn)), 64))
        ])
      ], void 0, true),
      _: 1
    }, 8, ["flip"]));
  }
});
export {
  Xn as default
};
